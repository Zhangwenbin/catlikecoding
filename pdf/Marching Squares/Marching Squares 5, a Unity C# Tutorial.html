<!DOCTYPE html>
<!-- saved from url=(0061)https://catlikecoding.com/unity/tutorials/marching-squares-5/ -->
<html><script type="text/javascript">
    var spector;
    var captureOnLoad = false;
    var captureOffScreen = false;
    window.__SPECTOR_Canvases = [];

    (function() {
        var __SPECTOR_Origin_EXTENSION_GetContext = HTMLCanvasElement.prototype.getContext;
        HTMLCanvasElement.prototype.__SPECTOR_Origin_EXTENSION_GetContext = __SPECTOR_Origin_EXTENSION_GetContext;

        HTMLCanvasElement.prototype.getContext = function () {
            var context = null;
            if (!arguments.length) {
                return context;
            }

            if (arguments.length === 1) {
                context = this.__SPECTOR_Origin_EXTENSION_GetContext(arguments[0]);
                if (context === null) {
                    return context;
                }
            }
            else if (arguments.length === 2) {
                context = this.__SPECTOR_Origin_EXTENSION_GetContext(arguments[0], arguments[1]);
                if (context === null) {
                    return context;
                }
            }

            var contextNames = ["webgl", "experimental-webgl", "webgl2", "experimental-webgl2"];
            if (contextNames.indexOf(arguments[0]) !== -1) {
                context.canvas.setAttribute("__spector_context_type", arguments[0]);
                // Notify the page a canvas is available.
                var myEvent = new CustomEvent("SpectorWebGLCanvasAvailableEvent");
                document.dispatchEvent(myEvent);

                if (captureOffScreen) {
                    var found = false;
                    for (var i = 0; i < window.__SPECTOR_Canvases.length; i++) {
                        if (window.__SPECTOR_Canvases[i] === this) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        window.__SPECTOR_Canvases.push(this);
                    }
                }

                if (captureOnLoad) {
                    // Ensures canvas is in the dom to capture the one we are currently tracking.
                    if (this.parentElement || false) {
                        spector.captureContext(context, 500, false);
                        captureOnLoad = false;
                    }
                }
            }

            return context;
        }
    })()</script><head prefix="og: http://ogp.me/ns#"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/marching-squares-5/">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/marching-squares-5/tutorial-image.jpg">
		<meta property="og:image:width" content="750">
		<meta property="og:image:height" content="430">
		<meta property="og:description" content="A Unity C# scripting tutorial in which you will extend Marching Squares to support multiple colors.">
		<meta name="description" content="A Unity C# scripting tutorial in which you will extend Marching Squares to support multiple colors.">
		<meta property="og:title" content="Marching Squares 5, a Unity C# Tutorial">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Marching Squares 5, a Unity C# Tutorial</title>
		<link href="./Marching Squares 5, a Unity C# Tutorial_files/tutorials.css" rel="stylesheet">

				<link rel="manifest" href="https://catlikecoding.com/site.webmanifest">
		<link rel="mask-icon" href="https://catlikecoding.com/safari-pinned-tab.svg" color="#aa0000">

		<script>
			var customTypes = {
				FeaturePoint: 1,
				Voxel: 1,
				VoxelCell: 1,
				VoxelGrid: 1,
				VoxelGridSurface: 1,
				VoxelGridWall: 1,
				VoxelMap: 1,
				VoxelMaterials: 1,
				VoxelRenderer: 1,
				VoxelStencil: 1,
				VoxelStencilCircle: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="https://catlikecoding.com/"><img src="./Marching Squares 5, a Unity C# Tutorial_files/catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<p><a href="https://catlikecoding.com/">Catlike Coding</a></p>
			<p class="category"><a href="https://catlikecoding.com/unity/tutorials/">Unity C# Tutorials</a></p>
		</header>
		
		<main>
			<article itemscope="" itemtype="http://schema.org/TechArticle">
				<header>
					<h1 itemprop="name headline">Marching Squares 5</h1>
					<p>Being Colorful</p>
					<ul>
						<li>Support more than two colors.</li>
						<li>Keep normals consistent.</li>
						<li>Distribute work among multiple structs and objects.</li>
						<li>Find a new way to triangulate.</li>
						<li>Deal with shared feature points.</li>
						<li>Make nice circles.</li>
					</ul>
				</header>

				<p itemprop="about description">In this tutorial we'll add support for multiple colors to Marching Squares.</p>

				<p itemprop="dependencies">This tutorial comes after <a href="https://catlikecoding.com/unity/tutorials/marching-squares-4/">Marching Squares 4</a>. Like the previous ones, it has been made with Unity 4.5.2 and might not work for older versions.</p>

				<figure>
					<img src="./Marching Squares 5, a Unity C# Tutorial_files/tutorial-image.jpg" width="375" height="215" itemprop="image">
					<figcaption>Say more with colors.</figcaption>
				</figure>
				
				<section>
					<h2>Adding More Choices</h2>
					
					<p>While using only two voxel states – empty and filled – already allows for complex and interesting shapes, allowing even more states would greatly enhance our expressiveness. Once we're able to deal with four different states we could support as many as we want, because each individual cell can contain up to four unique states.</p>
					
					<p>Let's start at the top with the UI and add more fill type options to <code><b class="type">VoxelMap</b>.</code> We need at least four but I'll make it five, the empty state and four filled ones. I'll label them with letters, naming the empty state <i>X</i> and placing it on the left side. That way the first index – voxel state zero – represents emptiness.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">static</b> <b class="type">string</b>[] fillTypeNames = {<mark><span class="constant">"X"</span>, <span class="constant">"A"</span>, <span class="constant">"B"</span>, <span class="constant">"C"</span>, <span class="constant">"D"</span></mark>};</pre>
					
					<p>Because starting with the eraser selected doesn't make much sense, you can set the default type selection to the first filled state, which would be <i>A</i>.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="type">int</b> fillTypeIndex <mark>= <span class="constant">1</span></mark>, radiusIndex, stencilIndex;</pre>
					
					<p>In <code>OnGUI</code>, put all five type buttons on a single line.</p>
					
					<pre translate="no">	fillTypeIndex =
			<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/GUILayout.html">GUILayout</a>.SelectionGrid(fillTypeIndex, fillTypeNames, <mark><span class="constant">5</span></mark>);</pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/01-xabcd.png" width="160" height="160">
						<figcaption>New fill types.</figcaption>
					</figure>
					
					<p>In <code>EditVoxels</code>, we used to pass a boolean fill type, but now we should pass the index itself.</p>
					
					<pre translate="no">	activeStencil.Initialize(
			<mark>fillTypeIndex</mark>, (radiusIndex + <span class="constant">0.5f</span>) * voxelSize);</pre>
					
					<p>Of course we now get compile errors because of a type mismatch, which means that we'll have to adjust <code><b class="type">VoxelStencil</b></code> next.</p>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-01-adding-more-choices.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Upgrading the Stencils</h2>
					
					<p>The fill type of <code><b class="type">VoxelStencil</b></code> needs to become an integer.</p>
					
					<pre translate="no">	<b class="keyword">protected</b> <mark><b class="type">int</b></mark> fillType;</pre>
					
					<p>Adjust the parameter type of <code>Initialize</code> as well, both in <code><b class="type">VoxelStencil</b></code> and <code><b class="type">VoxelStencilCircle</b></code>.</p>
					
					<pre translate="no">… <b class="keyword">void</b> Initialize (<mark><b class="type">int</b></mark> fillType, <b class="type">float</b> radius) …</pre>
					
					<p>More compiler errors show up. For now just change the state type in <code><b class="type">Voxel</b></code>, then ignore the errors produced in the grid.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <mark><b class="type">int</b></mark> state;</pre>
						
					<p>Back to <code><b class="type">VoxelStencil</b></code>. When finding a crossing, the fill type is used to determine which way the normal should point. But what way to point the edge normal between two filled sides? Although we won't need normals for a wall there, we do need then to detect sharp features. The most important thing here is consistency. Let them always point toward the side with the lowest index. That way the normals are guaranteed to be correctly oriented at the boundary between filled and empty space.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/02-normal-directions.png" width="150" height="150">
						<figcaption>Always point down.</figcaption>
					</figure>
					
					<pre translate="no">	<b class="keyword">protected</b> <b class="keyword">virtual</b> <b class="keyword">void</b> FindHorizontalCrossing (<b class="type">Voxel</b> xMin, <b class="type">Voxel</b> xMax) {
		<b class="keyword">if</b> (xMin.position.y &lt; YStart || xMin.position.y &gt; YEnd) {
			<b class="keyword">return</b>;
		}
		<b class="keyword">if</b> (xMin.state == fillType) {
			<b class="keyword">if</b> (xMin.position.x &lt;= XEnd &amp;&amp; xMax.position.x &gt;= XEnd) {
				<b class="keyword">if</b> (xMin.xEdge == <b class="type">float</b>.MinValue || xMin.xEdge &lt; XEnd) {
					xMin.xEdge = XEnd;
					xMin.xNormal =
						<b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(fillType <mark>&gt; xMax.state</mark> ? <span class="constant">1f</span> : -<span class="constant">1f</span>, <span class="constant">0f</span>);
				}
			}
		}
		<b class="keyword">else</b> <b class="keyword">if</b> (xMax.state == fillType) {
			<b class="keyword">if</b> (xMin.position.x &lt;= XStart &amp;&amp; xMax.position.x &gt;= XStart) {
				<b class="keyword">if</b> (xMin.xEdge == <b class="type">float</b>.MinValue || xMin.xEdge &gt; XStart) {
					xMin.xEdge = XStart;
					xMin.xNormal =
						<b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(fillType <mark>&gt; xMin.state</mark> ? -<span class="constant">1f</span> : <span class="constant">1f</span>, <span class="constant">0f</span>);
				}
			}
		}
	}</pre>
					
					<p>However, this only works when there wasn't a crossing before or if we're moving beyond an existing one. What to do when cutting behind another edge? Realistically that would leave a fragment of the old material behind, but we cannot store this information so have to discard it. Once again let's simply be consistent and leave the edge where it is, effectively extending the range of our edit.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/02-exact-vs-possible.png" width="360" height="360">
						<figcaption>Exact vs. possible result.</figcaption>
					</figure>
					
					<p>We still have to make sure that the normal points in the right direction. Let's add a validation method which flips the normal when it's pointing in the wrong direction. First for horizontal crossings.</p>
					
					<pre translate="no">	<b class="keyword">protected</b> <b class="keyword">virtual</b> <b class="keyword">void</b> FindHorizontalCrossing (<b class="type">Voxel</b> xMin, <b class="type">Voxel</b> xMax) {
		<b class="keyword">if</b> (xMin.position.y &lt; YStart || xMin.position.y &gt; YEnd) {
			<b class="keyword">return</b>;
		}
		<b class="keyword">if</b> (xMin.state == fillType) {
			<b class="keyword">if</b> (xMin.position.x &lt;= XEnd &amp;&amp; xMax.position.x &gt;= XEnd) {
				<b class="keyword">if</b> (xMin.xEdge == <b class="type">float</b>.MinValue || xMin.xEdge &amp; XEnd) {
					xMin.xEdge = XEnd;
					xMin.xNormal =
						<b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(fillType &gt; xMax.state ? <span class="constant">1f</span> : -<span class="constant">1f</span>, <span class="constant">0f</span>);
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>ValidateHorizontalNormal(xMin, xMax);</mark>
				<mark>}</mark>
			}
		}
		<b class="keyword">else</b> <b class="keyword">if</b> (xMax.state == fillType) {
			<b class="keyword">if</b> (xMin.position.x &lt;= XStart &amp;&amp; xMax.position.x &gt;= XStart) {
				<b class="keyword">if</b> (xMin.xEdge == <b class="type">float</b>.MinValue || xMin.xEdge &gt; XStart) {
					xMin.xEdge = XStart;
					xMin.xNormal =
						<b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(fillType &gt; xMin.state ? -<span class="constant">1f</span> : <span class="constant">1f</span>, <span class="constant">0f</span>);
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>ValidateHorizontalNormal(xMin, xMax);</mark>
				<mark>}</mark>
			}
		}
	}
	
	<mark><b class="keyword">protected</b> <b class="keyword">static</b> <b class="keyword">void</b> ValidateHorizontalNormal (<b class="type">Voxel</b> xMin, <b class="type">Voxel</b> xMax) {</mark>
		<mark><b class="keyword">if</b> (xMin.state &lt; xMax.state) {</mark>
			<mark><b class="keyword">if</b> (xMin.xNormal.x &gt; <span class="constant">0f</span>) {</mark>
				<mark>xMin.xNormal = -xMin.xNormal;</mark>
			<mark>}</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> <b class="keyword">if</b> (xMin.xNormal.x &lt; <span class="constant">0f</span>) {</mark>
			<mark>xMin.xNormal = -xMin.xNormal;</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>And the same for the vertical crossings.</p>
					
					<pre translate="no">	<b class="keyword">protected</b> <b class="keyword">virtual</b> <b class="keyword">void</b> FindVerticalCrossing (<b class="type">Voxel</b> yMin, <b class="type">Voxel</b> yMax) {
		<b class="keyword">if</b> (yMin.position.x &lt; XStart || yMin.position.x &gt; XEnd) {
			<b class="keyword">return</b>;
		}
		<b class="keyword">if</b> (yMin.state == fillType) {
			<b class="keyword">if</b> (yMin.position.y &lt;= YEnd &amp;&amp; yMax.position.y &gt;= YEnd) {
				<b class="keyword">if</b> (yMin.yEdge == <b class="type">float</b>.MinValue || yMin.yEdge &lt; YEnd) {
					yMin.yEdge = YEnd;
					yMin.yNormal =
						<b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(<span class="constant">0f</span>, fillType <mark>&gt; yMax.state</mark> ? <span class="constant">1f</span> : -<span class="constant">1f</span>);
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>ValidateVerticalNormal(yMin, yMax);</mark>
				<mark>}</mark>
			}
		}
		<b class="keyword">else</b> <b class="keyword">if</b> (yMax.state == fillType) {
			<b class="keyword">if</b> (yMin.position.y &lt;= YStart &amp;&amp; yMax.position.y &gt;= YStart) {
				<b class="keyword">if</b> (yMin.yEdge == <b class="type">float</b>.MinValue || yMin.yEdge &gt; YStart) {
					yMin.yEdge = YStart;
					yMin.yNormal =
						<b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(<span class="constant">0f</span>, fillType <mark>&gt; yMin.state</mark> ? -<span class="constant">1f</span> : <span class="constant">1f</span>);
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>ValidateVerticalNormal(yMin, yMax);</mark>
				<mark>}</mark>
			}
		}
	}
	
	<mark><b class="keyword">protected</b> <b class="keyword">static</b> <b class="keyword">void</b> ValidateVerticalNormal (<b class="type">Voxel</b> yMin, <b class="type">Voxel</b> yMax) {</mark>
		<mark><b class="keyword">if</b> (yMin.state &lt; yMax.state) {</mark>
			<mark><b class="keyword">if</b> (yMin.yNormal.y &gt; <span class="constant">0f</span>) {</mark>
				<mark>yMin.yNormal = -yMin.yNormal;</mark>
			<mark>}</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> <b class="keyword">if</b> (yMin.yNormal.y &lt; <span class="constant">0f</span>) {</mark>
			<mark>yMin.yNormal = -yMin.yNormal;</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p><code><b class="type">VoxelStencilCircle</b></code> needs to receive the same treatment. As it uses a separate <code>ComputeNormal</code> method to find the normal, let's just pass the other voxel to that method and have it compare the states.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> ComputeNormal (<b class="type">float</b> x, <b class="type">float</b> y<mark>, <b class="type">Voxel</b> other</mark>) {
		<b class="keyword">if</b> (fillType <mark>&gt; other.state</mark>) {
			<b class="keyword">return</b> <b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(x - centerX, y - centerY).normalized;
		}
		<b class="keyword">else</b> {
			<b class="keyword">return</b> <b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(centerX - x, centerY - y).normalized;
		}
	}</pre>
					
					<p>Then adjust the crossing methods.</p>
					
					<pre translate="no"><b class="keyword">protected</b> <b class="keyword">override</b> <b class="keyword">void</b> FindHorizontalCrossing (<b class="type">Voxel</b> xMin, <b class="type">Voxel</b> xMax) {
		<b class="type">float</b> y2 = xMin.position.y - centerY;
		y2 *= y2;
		<b class="keyword">if</b> (xMin.state == fillType) {
			<b class="type">float</b> x = xMin.position.x - centerX;
			<b class="keyword">if</b> (x * x + y2 &lt;= sqrRadius) {
				x = centerX + <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Sqrt(sqrRadius - y2);
				<b class="keyword">if</b> (xMin.xEdge == <b class="type">float</b>.MinValue || xMin.xEdge &lt; x) {
					xMin.xEdge = x;
					xMin.xNormal = ComputeNormal(x, xMin.position.y<mark>, xMax</mark>);
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>ValidateHorizontalNormal(xMin, xMax);</mark>
				<mark>}</mark>
			}
		}
		<b class="keyword">else</b> <b class="keyword">if</b> (xMax.state == fillType) {
			<b class="type">float</b> x = xMax.position.x - centerX;
			<b class="keyword">if</b> (x * x + y2 &lt;= sqrRadius) {
				x = centerX - <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Sqrt(sqrRadius - y2);
				<b class="keyword">if</b> (xMin.xEdge == <b class="type">float</b>.MinValue || xMin.xEdge &gt; x) {
					xMin.xEdge = x;
					xMin.xNormal = ComputeNormal(x, xMin.position.y<mark>, xMin</mark>);
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>ValidateHorizontalNormal(xMin, xMax);</mark>
				<mark>}</mark>
			}
		}
	}
	
	<b class="keyword">protected</b> <b class="keyword">override</b> <b class="keyword">void</b> FindVerticalCrossing (<b class="type">Voxel</b> yMin, <b class="type">Voxel</b> yMax) {
		<b class="type">float</b> x2 = yMin.position.x - centerX;
		x2 *= x2;
		<b class="keyword">if</b> (yMin.state == fillType) {
			<b class="type">float</b> y = yMin.position.y - centerY;
			<b class="keyword">if</b> (y * y + x2 &lt;= sqrRadius) {
				y = centerY + <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Sqrt(sqrRadius - x2);
				<b class="keyword">if</b> (yMin.yEdge == <b class="type">float</b>.MinValue || yMin.yEdge &lt; y) {
					yMin.yEdge = y;
					yMin.yNormal = ComputeNormal(yMin.position.x, y<mark>, yMax</mark>);
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>ValidateVerticalNormal(yMin, yMax);</mark>
				<mark>}</mark>
			}
		}
		<b class="keyword">else</b> <b class="keyword">if</b> (yMax.state == fillType) {
			<b class="type">float</b> y = yMax.position.y - centerY;
			<b class="keyword">if</b> (y * y + x2 &lt;= sqrRadius) {
				y = centerY - <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Sqrt(sqrRadius - x2);
				<b class="keyword">if</b> (yMin.yEdge == <b class="type">float</b>.MinValue || yMin.yEdge &gt; y) {
					yMin.yEdge = y;
					yMin.yNormal = ComputeNormal(yMin.position.x, y<mark>, yMin</mark>);
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>ValidateVerticalNormal(yMin, yMax);</mark>
				<mark>}</mark>
			}
		}
	}</pre>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-02-upgrading-the-stencils.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Working with Different Voxel Visualizations</h2>
					
					<p>The quick way to fix the errors in <code><b class="type">VoxelGrid</b></code> is to replace all seven test for <code>voxel.state</code> with <code>voxel.Filled</code>. Then we can paint again and actually mix different voxel types, though we won't see different colors yet. Of course we need to add that handy property to <code><b class="type">Voxel</b></code> to make it work.</p>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="type">bool</b> Filled {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="keyword">return</b> state &gt; <span class="constant">0f</span>;</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>We need materials to visualize the different states. Each filled state should have its own surface material and wall material. We can add two material arrays to <code><b class="type">VoxelGrid</b></code> to hold them. Alternatively, we could add a single array of pairs of these materials, which fits the relationship between the materials better. To do so, we need to define a simple structure for the pairs.</p>
					
					<pre translate="no"><mark><b class="keyword">using</b> UnityEngine;</mark>
<mark><b class="keyword">using</b> System;</mark>

<mark>[<a class="msdn-type" href="https://learn.microsoft.com/en-us/search/?category=Reference&amp;scope=.NET&amp;terms=Serializable">Serializable</a>]</mark>
<mark><b class="keyword">public</b> <b class="keyword">struct</b> <b class="type">VoxelMaterials</b> {</mark>

	<mark><b class="keyword">public</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Material.html">Material</a> surfaceMaterial, wallMaterial;</mark>
<mark>}</mark></pre>
					
					<p>Now we can add an array of those to <code><b class="type">VoxelGrid</b></code>.</p>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="type">VoxelMaterials</b>[] materials;</mark></pre>
					
					<p>Then create three more pairs of materials. That gives us a total of four pairs, as the empty state doesn't need materials. Use whatever colors you like. I tidied up the project a bit too.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/03-materials.png" width="598" height="476">
						<figcaption>New fill types.</figcaption>
					</figure>
					
					<p>Both <code><b class="type">VoxelGridSurface</b></code> and <code><b class="type">VoxelGridWall</b></code> now need to be initialized with a material.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <b class="keyword">void</b> Initialize (<b class="type">int</b> resolution<mark>, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Material.html">Material</a> material</mark>) {
		<mark><a class="unity-method" href="http://docs.unity3d.com/Documentation/ScriptReference/Component.GetComponent.html">GetComponent</a>&lt;<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/MeshRenderer.html">MeshRenderer</a>&gt;().material = material;</mark>
		…
	}</pre>
					
					<p>Because managing all the different meshes is becoming more complex, let's create a <code><a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/MeshRenderer.html">MeshRenderer</a></code> structure to encapsulate surface–wall pairs, just like for the materials.</p>
					
					<pre translate="no"><mark><b class="keyword">using</b> UnityEngine;</mark>
<mark><b class="keyword">using</b> System;</mark>

<mark>[<a class="msdn-type" href="https://learn.microsoft.com/en-us/search/?category=Reference&amp;scope=.NET&amp;terms=Serializable">Serializable</a>]</mark>
<mark><b class="keyword">public</b> <b class="keyword">struct</b> <b class="type">VoxelRenderer</b> {</mark>
	
	<mark>[<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/SerializeField.html">SerializeField</a>]</mark>
	<mark><b class="keyword">private</b> <b class="type">VoxelGridSurface</b> surface;</mark>
	
	<mark>[<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/SerializeField.html">SerializeField</a>]</mark>
	<mark><b class="keyword">private</b> <b class="type">VoxelGridWall</b> wall;</mark>
	
	<mark><b class="keyword">public</b> <b class="type">VoxelRenderer</b> (<b class="type">VoxelGridSurface</b> surface, <b class="type">VoxelGridWall</b> wall) {</mark>
		<mark><b class="keyword">this</b>.surface = surface;</mark>
		<mark><b class="keyword">this</b>.wall = wall;</mark>
	<mark>}</mark>
<mark>}</mark></pre>
					
					<p>Now <code><b class="type">VoxelGrid</b></code> can use a single array of those instead of having to worry about separate surfaces and walls.</p>
					
					<pre translate="no">	<mark><b class="keyword">private</b> <b class="type">VoxelRenderer</b>[] renderers;</mark></pre>
					
					<p>Create the renderers when initializing <code><b class="type">VoxelGrid</b></code>. Use the amount of materials to determine how many different visualizations we need. Instantiate the prefabs as normal, initialize them with the correct materials, and put them into a new renderer.</p>
					
					<p>Actually, create one more renderers than needed, and then skip the first one during initialization. This way we can use the voxel state to directly index the renderers array, instead of having to subtract one from it each time.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <b class="keyword">void</b> Initialize (<b class="type">int</b> resolution, <b class="type">float</b> size, <b class="type">float</b> maxFeatureAngle) {
		…
		
		<b class="keyword">for</b> (<b class="type">int</b> i = <span class="constant">0</span>, y = <span class="constant">0</span>; y &lt; resolution; y++) {
			<b class="keyword">for</b> (<b class="type">int</b> x = <span class="constant">0</span>; x &lt; resolution; x++, i++) {
				CreateVoxel(i, x, y);
			}
		}

		<mark>CreateRenderers();</mark>
		Refresh();
	}

	<mark><b class="keyword">private</b> <b class="keyword">void</b> CreateRenderers () {</mark>
		<mark>renderers = <b class="keyword">new</b> <b class="type">VoxelRenderer</b>[materials.Length + <span class="constant">1</span>];</mark>
		<mark><b class="keyword">for</b> (<b class="type">int</b> i = <span class="constant">0</span>; i &lt; materials.Length; i++) {</mark>
			<mark><b class="type">VoxelGridSurface</b></mark> surface =
				<a class="unity-method" href="http://docs.unity3d.com/Documentation/ScriptReference/Object.Instantiate.html">Instantiate</a>(surfacePrefab) <b class="keyword">as</b> <b class="type">VoxelGridSurface</b>;
			surface.transform.parent = transform;
			surface.transform.localPosition = <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a>.zero;
			surface.Initialize(resolution<mark>, materials[i].surfaceMaterial</mark>);
			
			<mark><b class="type">VoxelGridWall</b></mark> wall = <a class="unity-method" href="http://docs.unity3d.com/Documentation/ScriptReference/Object.Instantiate.html">Instantiate</a>(wallPrefab) <b class="keyword">as</b> <b class="type">VoxelGridWall</b>;
			wall.transform.parent = transform;
			wall.transform.localPosition = <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a>.zero;
			wall.Initialize(resolution<mark>, materials[i].wallMaterial</mark>);
			
			<mark>renderers[i + <span class="constant">1</span>] = <b class="keyword">new</b> <b class="type">VoxelRenderer</b>(s, w);</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>After initialization the grid now only works with the renderers and will no longer directly access the surfaces and walls. This means that <code><b class="type">VoxelRenderer</b></code> now has to accept caching commands and forward them to its surface and wall. So we have to give it some methods to support this.</p>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="keyword">void</b> Clear () {</mark>
		<mark>surface.Clear();</mark>
		<mark>wall.Clear();</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="keyword">void</b> Apply () {</mark>
		<mark>surface.Apply();</mark>
		<mark>wall.Apply();</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="keyword">void</b> PrepareCacheForNextCell () {</mark>
		<mark>surface.PrepareCacheForNextCell();</mark>
		<mark>wall.PrepareCacheForNextCell();</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="keyword">void</b> PrepareCacheForNextRow () {</mark>
		<mark>surface.PrepareCacheForNextRow();</mark>
		<mark>wall.PrepareCacheForNextRow();</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> CacheFirstCorner (<b class="type">Voxel</b> voxel) {</mark>
		<mark>surface.CacheFirstCorner(voxel);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> CacheNextCorner (<b class="type">int</b> i, <b class="type">Voxel</b> voxel) {</mark>
		<mark>surface.CacheNextCorner(i, voxel);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> CacheXEdge (<b class="type">int</b> i, <b class="type">Voxel</b> voxel) {</mark>
		<mark>surface.CacheXEdge(i, voxel);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> CacheXEdgeWithWall (<b class="type">int</b> i, <b class="type">Voxel</b> voxel) {</mark>
		<mark>surface.CacheXEdge(i, voxel);</mark>
		<mark>wall.CacheXEdge(i, voxel);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> CacheYEdge (<b class="type">Voxel</b> voxel) {</mark>
		<mark>surface.CacheYEdge(voxel);</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="keyword">void</b> CacheYEdgeWithWall (<b class="type">Voxel</b> voxel) {</mark>
		<mark>surface.CacheYEdge(voxel);</mark>
		<mark>wall.CacheYEdge(voxel);</mark>
	<mark>}</mark></pre>
					
					<p>Now <code><b class="type">VoxelGrid</b></code> has to invoke these methods instead of the old ones. First, all renderers for non-empty states need to be cleared and applied.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate () {
		<mark><b class="keyword">for</b> (<b class="type">int</b> i = <span class="constant">1</span>; i &lt; renderers.Length; i++) {</mark>
			<mark>renderers[i]</mark>.Clear();
		<mark>}</mark>
		FillFirstRowCache();
		TriangulateCellRows();
		<b class="keyword">if</b> (yNeighbor != <b class="keyword">null</b>) {
			TriangulateGapRow();
		}
		<mark><b class="keyword">for</b> (<b class="type">int</b> i = <span class="constant">1</span>; i &lt; renderers.Length; i++) {</mark>
			<mark>renderers[i]</mark>.Apply();
		<mark>}</mark>
	}</pre>
					
					<p>Caching needs to access the correct renderer, which we made possibly by simply indexing the array using the voxel state. The first corner is easy.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> CacheFirstCorner (<b class="type">Voxel</b> voxel) {
		<b class="keyword">if</b> (voxel.Filled) {
			<mark>renderers[voxel.state]</mark>.CacheFirstCorner(voxel);
		}
	}</pre>
					
					<p>The next corner and edge also needs to determine which renderers to use, and whether there's a wall or a second renderer involved.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> CacheNextEdgeAndCorner (<b class="type">int</b> i, <b class="type">Voxel</b> xMin, <b class="type">Voxel</b> xMax) {
		<b class="keyword">if</b> (xMin.state != xMax.state) {
			<mark><b class="keyword">if</b> (xMin.Filled) {</mark>
				<mark><b class="keyword">if</b> (xMax.Filled) {</mark>
					<mark>renderers[xMin.state].CacheXEdge(i, xMin);</mark>
					<mark>renderers[xMax.state].CacheXEdge(i, xMin);</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> {</mark>
					<mark>renderers[xMin.state].CacheXEdgeWithWall(i, xMin);</mark>
				<mark>}</mark>
			<mark>}</mark>
			<mark><b class="keyword">else</b> {</mark>
				<mark>renderers[xMax.state].CacheXEdgeWithWall(i, xMin);</mark>
			<mark>}</mark>
		}
		<b class="keyword">if</b> (xMax.Filled) {
			<mark>renderers[xMax.state].</mark>CacheNextCorner(i, xMax);
		}
	}</pre>
					
					<p>The next middle edge has the same questions to ask. It also needs to prepare all renderers for the next cell.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> CacheNextMiddleEdge (<b class="type">Voxel</b> yMin, <b class="type">Voxel</b> yMax) {
		<mark><b class="keyword">for</b> (<b class="type">int</b> i = <span class="constant">1</span>; i &lt; renderers.Length; i++) {</mark>
			<mark>renderers[i]</mark>.PrepareCacheForNextCell();
		<mark>}</mark>
		<b class="keyword">if</b> (yMin.state != yMax.state) {
			<mark><b class="keyword">if</b> (yMin.Filled) {</mark>
				<mark><b class="keyword">if</b> (yMax.Filled) {</mark>
					<mark>renderers[yMin.state].CacheYEdge(yMin);</mark>
					<mark>renderers[yMax.state].CacheYEdge(yMin);</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> {</mark>
					<mark>renderers[yMin.state].CacheYEdgeWithWall(yMin);</mark>
				<mark>}</mark>
			<mark>}</mark>
			<mark><b class="keyword">else</b> {</mark>
				<mark>renderers[yMax.state].CacheYEdgeWithWall(yMin);</mark>
			<mark>}</mark>
		}
	}</pre>
					
					<p>And finally the row caches need to be swapped.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> SwapRowCaches () {
		<mark><b class="keyword">for</b> (<b class="type">int</b> i = <span class="constant">1</span>; i &lt; renderers.Length; i++) {</mark>
			<mark>renderers[i]</mark>.PrepareCacheForNextRow();
		<mark>}</mark>
	}</pre>
					
					<p>Now remove the <code>surface</code> and <code>wall</code> variable declarations. This causes compile errors in all triangulations method, but they are no longer valid anyway. You can remove or comment out all that code.</p>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-03-working-with-different-voxel-visualizations.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Formalizing a Cell</h2>
					
					<p>We often talk about cells, but we don't have a cell entity. Instead of constantly passing sets of voxels around, let's create a cell object that stores four voxels. It is also the natural place for any method that analyzes the contents of a cells, so let's store the sharp feature limit in it too.</p>
					
					<pre translate="no"><mark><b class="keyword">using</b> UnityEngine;</mark>
<mark><b class="keyword">using</b> System;</mark>

<mark>[<a class="msdn-type" href="https://learn.microsoft.com/en-us/search/?category=Reference&amp;scope=.NET&amp;terms=Serializable">Serializable</a>]</mark>
<mark><b class="keyword">public</b> <b class="keyword">class</b> <b class="type">VoxelCell</b> {</mark>

	<mark>[<a class="msdn-type" href="https://learn.microsoft.com/en-us/search/?category=Reference&amp;scope=.NET&amp;terms=NonSerialized">NonSerialized</a>]</mark>
	<mark><b class="keyword">public</b> <b class="type">Voxel</b> a, b, c, d;</mark>
	
	<mark>[<a class="msdn-type" href="https://learn.microsoft.com/en-us/search/?category=Reference&amp;scope=.NET&amp;terms=NonSerialized">NonSerialized</a>]</mark>
	<mark><b class="keyword">public</b> <b class="type">int</b> i;</mark>
	
	<mark><b class="keyword">public</b> <b class="type">float</b> sharpFeatureLimit;</mark>
<mark>}</mark></pre>
					
					<p>It's simply a convenient data package that we add to <code><b class="type">VoxelGrid</b></code> as a private variable. This way we no longer need to move all this data around all the time.</p>
					
					<pre translate="no">	<mark><b class="keyword">private</b> <b class="type">VoxelCell</b> cell = <b class="keyword">new</b> <b class="type">VoxelCell</b>();</mark>

	<b class="keyword">public</b> <b class="keyword">void</b> Initialize (<b class="type">int</b> resolution, <b class="type">float</b> size, <b class="type">float</b> maxFeatureAngle) {
		<mark>cell.</mark>sharpFeatureLimit = <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Cos(maxFeatureAngle * <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Deg2Rad);
		…
	}</pre>
					
					<p>Now we can put all code about finding sharp features into the cell. Ideally these are simply properties that give us a desired feature point, or nothing if it doesn't exist. To facilitate this, create a feature point struct that contains both its position and whether it actually exists.</p>
					
					<pre translate="no"><mark><b class="keyword">using</b> UnityEngine;</mark>

<mark><b class="keyword">public</b> <b class="keyword">struct</b> <b class="type">FeaturePoint</b> {</mark>
	
	<mark><b class="keyword">public</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> position;</mark>
	
	<mark><b class="keyword">public</b> <b class="type">bool</b> exists;</mark>
<mark>}</mark></pre>
					
					<p>Now we can add convenient properties to <code><b class="type">VoxelCell</b></code>. Let's also label the four edges using compass directions, as W is easier to read than AC and so on.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/04-nesw.png" width="150" height="150">
						<figcaption>Compass labels for edges.</figcaption>
					</figure>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureSW {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="keyword">return</b> GetSharpFeature(</mark>
				<mark>a.XEdgePoint, a.xNormal, a.YEdgePoint, a.yNormal);</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureSE {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="keyword">return</b> GetSharpFeature(</mark>
				<mark>a.XEdgePoint, a.xNormal, b.YEdgePoint, b.yNormal);</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureNW {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="keyword">return</b> GetSharpFeature(</mark>
				<mark>a.YEdgePoint, a.yNormal, c.XEdgePoint, c.xNormal);</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureNE {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="keyword">return</b> GetSharpFeature(</mark>
				<mark>c.XEdgePoint, c.xNormal, b.YEdgePoint, b.yNormal);</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureNS {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="keyword">return</b> GetSharpFeature(</mark>
				<mark>a.XEdgePoint, a.xNormal, c.XEdgePoint, c.xNormal);</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureEW {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="keyword">return</b> GetSharpFeature(</mark>
				<mark>a.YEdgePoint, a.yNormal, b.YEdgePoint, b.yNormal);</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>As these properties have to decide whether a feature point exists without any context, we cannot know whether it's fine to clamp them or not. So we simply won't. A feature exist if it's sharp enough and lies inside the cell, otherwise it doesn't. This sacrifices some of the fidelity of our visualization, but simplifies our code.</p>
					
					<pre translate="no">	<mark><b class="keyword">private</b> <b class="type">FeaturePoint</b> GetSharpFeature (</mark>
		<mark><a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> p1, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n1, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> p2, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2) {</mark>

		<mark><b class="type">FeaturePoint</b> point;</mark>
		<mark><b class="keyword">if</b> (IsSharpFeature(n1, n2)) {</mark>
			<mark>point.position = GetIntersection(p1, n1, p2, n2);</mark>
			<mark>point.exists = Contains(point.position);</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>point.position = <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>.zero;</mark>
			<mark>point.exists = <b class="keyword">false</b>;</mark>
		<mark>}</mark>
		<mark><b class="keyword">return</b> point;</mark>
	<mark>}</mark></pre>
					
					<p>The three methods used here are the same that were previously in <code><b class="type">VoxelGrid</b></code>, just moved to <code><b class="type">VoxelCell</b></code>.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="type">bool</b> IsSharpFeature (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n1, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2) {
		<b class="type">float</b> dot = <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>.Dot(n1, -n2);
		<b class="keyword">return</b> dot &gt;= sharpFeatureLimit &amp;&amp; dot &lt; <span class="constant">0.9999f</span>;
	}
	
	<b class="keyword">private</b> <b class="keyword">static</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> GetIntersection (
		<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> p1, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n1, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> p2, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2) {
		
		<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> d2 = <b class="keyword">new</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>(-n2.y, n2.x);
		<b class="type">float</b> u2 = -<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>.Dot(n1, p2 - p1) / <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>.Dot(n1, d2);
		<b class="keyword">return</b> p2 + d2 * u2;
	}

	<b class="keyword">private</b> <b class="type">bool</b> IsInsideCell (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> point) {
		<b class="keyword">return</b>
			point.x &gt; a.position.x &amp;&amp; amp;point.y &gt; a.position.y &amp;&amp;
				point.x &lt; d.position.x &amp;&amp; point.y &lt; d.position.y;
	}</pre>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-04-formalizing-a-cell.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Filling Cells</h2>
					
					<p>Rendering cells with triangles is now the job of the renderers. <code><b class="type">VoxelGrid</b></code> still figures out the topology of a cell, then leaves it up to the renderers to fill the cell with walls and surfaces.</p>
					
					<p>When working through the topology of a cell, ideally we no longer care whether a certain state is empty or filled. It's convenient to just invoke a filling method for any state. These fill methods then check whether the state is actually filled, and if so forward the request to the appropriate renderer. Otherwise it simply does nothing. Here's such a method for filling an isolated A corner.</p>
					
					<pre translate="no">	<mark><b class="keyword">private</b> <b class="keyword">void</b> FillA (<b class="type">FeaturePoint</b> f) {</mark>
		<mark><b class="keyword">if</b> (cell.a.Filled) {</mark>
			<mark>renderers[cell.a.state].FillA(cell, f);</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>Passing the cell to <code><b class="type">VoxelRenderer</b></code> allows it to figure out whether it needs to place walls. In case of a sharp feature each side needs to be checked separately, because they could have different voxel states. If there is no feature, then both adjacent voxels should have the same state and these separate checks are not needed.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/05-a.png" width="300" height="150">
						<figcaption>To place or not to place walls for A.</figcaption>
					</figure>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="keyword">void</b> FillA (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {</mark>
		<mark><b class="keyword">if</b> (f.exists) {</mark>
			<mark>surface.AddQuadA(cell.i, f.position);</mark>
			<mark><b class="keyword">if</b> (!cell.c.Filled) {</mark>
				<mark>wall.AddFromAC(cell.i, f.position);</mark>
			<mark>}</mark>
			<mark><b class="keyword">if</b> (!cell.b.Filled) {</mark>
				<mark>wall.AddToAB(cell.i, f.position);</mark>
			<mark>}</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>surface.AddTriangleA(cell.i);</mark>
			<mark><b class="keyword">if</b> (!cell.b.Filled) {</mark>
				<mark>wall.AddACAB(cell.i);</mark>
			<mark>}</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>This means that <code><b class="type">VoxelGridWall</b></code> need to support adding sections that go from an edge to a feature point, or from a feature point to an edge. Half sections, if you will.</p>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="keyword">void</b> AddFromAB (<b class="type">int</b> i, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> extraVertex) {</mark>
		<mark>AddHalfSection(xEdgesMin[i], extraVertex);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> AddToAB (<b class="type">int</b> i, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> extraVertex) {</mark>
		<mark>AddHalfSection(extraVertex, xEdgesMin[i]);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> AddFromAC (<b class="type">int</b> i, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> extraVertex) {</mark>
		<mark>AddHalfSection(yEdgeMin, extraVertex);</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="keyword">void</b> AddToAC (<b class="type">int</b> i, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> extraVertex) {</mark>
		<mark>AddHalfSection(extraVertex, yEdgeMin);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> AddFromBD (<b class="type">int</b> i, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> extraVertex) {</mark>
		<mark>AddHalfSection(yEdgeMax, extraVertex);</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="keyword">void</b> AddToBD (<b class="type">int</b> i, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> extraVertex) {</mark>
		<mark>AddHalfSection(extraVertex, yEdgeMax);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="keyword">void</b> AddFromCD (<b class="type">int</b> i, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> extraVertex) {</mark>
		<mark>AddHalfSection(xEdgesMax[i], extraVertex);</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="keyword">void</b> AddToCD (<b class="type">int</b> i, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> extraVertex) {</mark>
		<mark>AddHalfSection(extraVertex, xEdgesMax[i]);</mark>
	<mark>}</mark></pre>
					
					<p>This assumes the existence of two <code>AddHalfSection</code> methods, so add those as well. While we're at it, we can extract the code that constructs a feature point and put that in its own method so we can reuse it.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> AddSection (<b class="type">int</b> a, <b class="type">int</b> b, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> extraPoint) {
		<mark>AddSection(a, AddPoint(extraPoint, a));</mark>
		<mark>AddSection(AddPoint(extraPoint, b), b);</mark>
	}

	<mark><b class="keyword">private</b> <b class="keyword">void</b> AddHalfSection (<b class="type">int</b> a, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> extraPoint) {</mark>
		<mark>AddSection(a, AddPoint(extraPoint, a));</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">private</b> <b class="keyword">void</b> AddHalfSection (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> extraPoint, <b class="type">int</b> a) {</mark>
		<mark>AddSection(AddPoint(extraPoint, a), a);</mark>
	<mark>}</mark>

	<mark><b class="keyword">private</b> <b class="type">int</b> AddPoint (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> extraPoint, <b class="type">int</b> normalIndex) {</mark>
		<b class="type">int</b> p = vertices.Count;
		extraPoint.z = bottom;
		vertices.Add(extraPoint);
		extraPoint.z = top;
		vertices.Add(extraPoint);
		<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> n = normals[<mark>normalIndex</mark>];
		normals.Add(n);
		normals.Add(n);
		<mark><b class="keyword">return</b> p;</mark>
	}</pre>
					
					<p>Let's go ahead and create all the other fill methods too. I won't bother showing the methods for <code><b class="type">VoxelGrid</b></code>, as they all have the same simple structure as <code>FillA</code>. Check if the relevant voxel is filled, if so index the renderers array and invoke the method with the same name.</p>
					
					<p>On to <code><b class="type">VoxelRenderer</b></code>! The other three single-corner methods are slight variations of <code>FillA</code>. I marked the differences.</p>
					
					<pre translate="no"><b class="keyword">public</b> <b class="keyword">void</b> <mark>FillB</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddQuadB</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddFromAB</mark>(cell.i, f.position);
			}
			<b class="keyword">if</b> (!cell.<mark>d</mark>.Filled) {
				wall.<mark>AddToBD</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddTriangleB</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddABBD</mark>(cell.i);
			}
		}
	}
	
	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillC</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddQuadC</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>d</mark>.Filled) {
				wall.<mark>AddFromCD</mark>(cell.i, f.position);
			}
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddToAC</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddTriangleC</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddCDAC</mark>(cell.i);
			}
		}
	}
	
	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillD</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddQuadD</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>b</mark>.Filled) {
				wall.<mark>AddFromBD</mark>(cell.i, f.position);
			}
			<b class="keyword">if</b> (!cell.<mark>c</mark>.Filled) {
				wall.<mark>AddToCD</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddTriangleD</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>b</mark>.Filled) {
				wall.<mark>AddBDCD</mark>(cell.i);
			}
		}
	}</pre>
					
					<p>Next up are the methods that fill all but one corner. These are simpler because there's only one adjacent state to check. Here's <code>FillABC</code>.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/05-abc.png" width="300" height="150">
						<figcaption>Wall placement examples for ABC.</figcaption>
					</figure>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="keyword">void</b> FillABC (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {</mark>
		<mark><b class="keyword">if</b> (f.exists) {</mark>
			<mark>surface.AddHexagonABC(cell.i, f.position);</mark>
			<mark><b class="keyword">if</b> (!cell.d.Filled) {</mark>
				<mark>wall.AddCDBD(cell.i, f.position);</mark>
			<mark>}</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>surface.AddPentagonABC(cell.i);</mark>
			<mark><b class="keyword">if</b> (!cell.d.Filled) {</mark>
				<mark>wall.AddCDBD(cell.i);</mark>
			<mark>}</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>And in the same vein for <code>FillABD</code>, <code>FillACD</code>, and <code>FillBCD</code>.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillABD</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddHexagonABD</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>c</mark>.Filled) {
				wall.<mark>AddACCD</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddPentagonABD</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>c</mark>.Filled) {
				wall.<mark>AddACCD</mark>(cell.i);
			}
		}
	}
	
	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillACD</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddHexagonACD</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>b</mark>.Filled) {
				wall.<mark>AddBDAB</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddPentagonACD</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>b</mark>.Filled) {
				wall.<mark>AddBDAB</mark>(cell.i);
			}
		}
	}
	
	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillBCD</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddHexagonBCD</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddABAC</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddPentagonBCD</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddABAC</mark>(cell.i);
			}
		}
	}</pre>
					
					<p>Then straight across a cell. We once again have to check twice whether to place a wall when there's a feature. Here's <code>FillAB</code>.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/05-ab.png" width="300" height="150">
						<figcaption>Wall placement examples for AB.</figcaption>
					</figure>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="keyword">void</b> FillAB (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {</mark>
		<mark><b class="keyword">if</b> (f.exists) {</mark>
			<mark>surface.AddPentagonAB(cell.i, f.position);</mark>
			<mark><b class="keyword">if</b> (!cell.c.Filled) {</mark>
				<mark>wall.AddFromAC(cell.i, f.position);</mark>
			<mark>}</mark>
			<mark><b class="keyword">if</b> (!cell.d.Filled) {</mark>
				<mark>wall.AddToBD(cell.i, f.position);</mark>
			<mark>}</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>surface.AddQuadAB(cell.i);</mark>
			<mark><b class="keyword">if</b> (!cell.c.Filled) {</mark>
				<mark>wall.AddACBD(cell.i);</mark>
			<mark>}</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>And the same for <code>FillAC</code>, <code>FillBD</code>, and <code>FillCD</code>.</p>
					
					<pre translate="no"><b class="keyword">public</b> <b class="keyword">void</b> <mark>FillAC</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddPentagonAC</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>d</mark>.Filled) {
				wall.<mark>AddFromCD</mark>(cell.i, f.position);
			}
			<b class="keyword">if</b> (!cell.<mark>b</mark>.Filled) {
				wall.<mark>AddToAB</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddQuadAC</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>b</mark>.Filled) {
				wall.<mark>AddCDAB</mark>(cell.i);
			}
		}
	}
	
	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillBD</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddPentagonBD</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddFromAB</mark>(cell.i, f.position);
			}
			<b class="keyword">if</b> (!cell.<mark>c</mark>.Filled) {
				wall.<mark>AddToCD</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddQuadBD</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddABCD</mark>(cell.i);
			}
		}
	}
	
	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillCD</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddPentagonCD</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>b</mark>.Filled) {
				wall.<mark>AddFromBD</mark>(cell.i, f.position);
			}
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddToAC</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddQuadCD</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddBDAC</mark>(cell.i);
			}
		}
	}</pre>
					
					<p>Then the four halves of diagonal connections. Remember that each of these work on a diagonal slice of a cell. Starting with <code>FillADToB</code>.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/05-ad-to-b.png" width="300" height="150">
						<figcaption>Wall placement examples for AD to B.</figcaption>
					</figure>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="keyword">void</b> FillADToB (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {</mark>
		<mark><b class="keyword">if</b> (f.exists) {</mark>
			<mark>surface.AddPentagonADToB(cell.i, f.position);</mark>
			<mark><b class="keyword">if</b> (!cell.b.Filled) {</mark>
				<mark>wall.AddBDAB(cell.i, f.position);</mark>
			<mark>}</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>surface.AddQuadADToB(cell.i);</mark>
			<mark><b class="keyword">if</b> (!cell.b.Filled) {</mark>
				<mark>wall.AddBDAB(cell.i);</mark>
			<mark>}</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>And of course <code>FillADToC</code>, <code>FillBCToA</code>, and <code>FillBCToD</code>.</p>
					
					<pre translate="no"><b class="keyword">public</b> <b class="keyword">void</b> <mark>FillADToC</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddPentagonADToC</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>c</mark>.Filled) {
				wall.<mark>AddACCD</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddQuadADToC</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>c</mark>.Filled) {
				wall.<mark>AddACCD</mark>(cell.i);
			}
		}
	}
	
	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillBCToA</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddPentagonBCToA</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddABAC</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddQuadBCToA</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>a</mark>.Filled) {
				wall.<mark>AddABAC</mark>(cell.i);
			}
		}
	}
	
	<b class="keyword">public</b> <b class="keyword">void</b> <mark>FillBCToD</mark> (<b class="type">VoxelCell</b> cell, <b class="type">FeaturePoint</b> f) {
		<b class="keyword">if</b> (f.exists) {
			surface.<mark>AddPentagonBCToD</mark>(cell.i, f.position);
			<b class="keyword">if</b> (!cell.<mark>d</mark>.Filled) {
				wall.<mark>AddCDBD</mark>(cell.i, f.position);
			}
		}
		<b class="keyword">else</b> {
			surface.<mark>AddQuadBCToD</mark>(cell.i);
			<b class="keyword">if</b> (!cell.<mark>d</mark>.Filled) {
				wall.<mark>AddCDBD</mark>(cell.i);
			}
		}
	}</pre>
					
					<p>The last one is simply a completely filled cell, so no checks are needed.</p>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="keyword">void</b> FillABCD (<b class="type">VoxelCell</b> cell) {</mark>
		<mark>surface.AddQuadABCD(cell.i);</mark>
	<mark>}</mark></pre>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-05-filling-cells.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Triangulating Anew</h2>
					
					<p>When we used only two states we had to identify sixteen different cell layouts. Now that each cell corner can have a unique state, the amount of possible combinations becomes much greater. However, if we ignore the exact colors and only concern ourselves with differences in state, we end up with only fifteen distinct possibilities.</p>
					
					<p>Consider corner A as our baseline. From our perspective, it is always the same. We represent it with the digit 0. Next consider corner B. If it has the same state as A, we also use 0 to describe it, otherwise we use the digit 1. We use the same approach for corners C and D, ending up with a four-digit label. The digits represent similarity, not specific material identifiers.</p>
					
					<p>For example, when A, B, and D have the same state while C has a different one, we label this case with 0010, regardless what the actual states are.</p>
					
					<p>Now suppose A and B have different states, while C ends up with yet another state. Then we use the digit 2 for C. And when all corners are different we need to use the digit 3 for D.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/06-cases.png" width="300" height="380">
						<figcaption>Fifteen unique cell layouts.</figcaption>
					</figure>
					
					<p>Unfortunately this means that we can no longer easily construct a number from the voxel state, we have to compare all the corners. But before we get to that, <code><b class="type">VoxelGrid</b>.TriangulateCell</code> should start by filling the cell with the current voxels and index.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> TriangulateCell (<b class="type">int</b> i, <b class="type">Voxel</b> a, <b class="type">Voxel</b> b, <b class="type">Voxel</b> c, <b class="type">Voxel</b> d) {
		<mark>cell.i = i;</mark>
		<mark>cell.a = a;</mark>
		<mark>cell.b = b;</mark>
		<mark>cell.c = c;</mark>
		<mark>cell.d = d;</mark>
	}</pre>
					
					<p>Then onwards to comparing voxels! Let's start with case 0000, when they all have the same state. Create method stubs for the new triangulation methods as you go.</p>
					
					<pre translate="no">		…
		
		<mark><b class="keyword">if</b> (a.state == b.state) {</mark>
			<mark><b class="keyword">if</b> (a.state == c.state) {</mark>
				<mark><b class="keyword">if</b> (a.state == d.state) {</mark>
					<mark>Triangulate0000();</mark>
				<mark>}</mark>
			<mark>}</mark>
		<mark>}</mark></pre>
					
					<p>If D turns out to be different, we have case 0001.</p>
					
					<pre translate="no">		<b class="keyword">if</b> (a.state == b.state) {
			<b class="keyword">if</b> (a.state == c.state) {
				<b class="keyword">if</b> (a.state == d.state) {
					Triangulate0000();
				}
				<mark><b class="keyword">else</b> {</mark>
					<mark>Triangulate0001();</mark>
				<mark>}</mark>
			}
		}</pre>
					
					<p>If C turned out to be not the same as A, then D can match either A, C, or none. That leads us to cases 0010, 0011, and 0012.</p>
					
					<pre translate="no">		<b class="keyword">if</b> (a.state == b.state) {
			<b class="keyword">if</b> (a.state == c.state) {
				…
			}
			<mark><b class="keyword">else</b> {</mark>
				<mark><b class="keyword">if</b> (a.state == d.state) {</mark>
					<mark>Triangulate0010();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> <b class="keyword">if</b> (c.state == d.state) {</mark>
					<mark>Triangulate0011();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> {</mark>
					<mark>Triangulate0012();</mark>
				<mark>}</mark>
			<mark>}</mark>
		}</pre>
					
					<p>Using the same logic we can arrive at all remaining cases.</p>
					
					<pre translate="no">		<b class="keyword">if</b> (a.state == b.state) {
			…
		}
		<mark><b class="keyword">else</b> {</mark>
			<mark><b class="keyword">if</b> (a.state == c.state) {</mark>
				<mark><b class="keyword">if</b> (a.state == d.state) {</mark>
					<mark>Triangulate0100();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> <b class="keyword">if</b> (b.state == d.state) {</mark>
					<mark>Triangulate0101();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> {</mark>
					<mark>Triangulate0102();</mark>
				<mark>}</mark>
			<mark>}</mark>
			<mark><b class="keyword">else</b> <b class="keyword">if</b> (b.state == c.state) {</mark>
				<mark><b class="keyword">if</b> (a.state == d.state) {</mark>
					<mark>Triangulate0110();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> <b class="keyword">if</b> (b.state == d.state) {</mark>
					<mark>Triangulate0111();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> {</mark>
					<mark>Triangulate0112();</mark>
				<mark>}</mark>
			<mark>}</mark>
			<mark><b class="keyword">else</b> {</mark>
				<mark><b class="keyword">if</b> (a.state == d.state) {</mark>
					<mark>Triangulate0120();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> <b class="keyword">if</b> (b.state == d.state) {</mark>
					<mark>Triangulate0121();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> <b class="keyword">if</b> (c.state == d.state) {</mark>
					<mark>Triangulate0122();</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> {</mark>
					<mark>Triangulate0123();</mark>
				<mark>}</mark>
			<mark>}</mark>
		<mark>}</mark></pre>
					
					<p>Let's first deal with the trivial case, 0000. Simply fill the entire cell.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0000 () {
		<mark>FillABCD();</mark>
	}</pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/06-uniform.png" width="270" height="240">
						<figcaption>Multiple colors show up for the first time.</figcaption>
					</figure>
					
					<p>Next up are the cells with a single deviant voxel. Because we don't care about specific voxel states, these are now very easy.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0001 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureNE;</mark>
		<mark>FillABC(f);</mark>
		<mark>FillD(f);</mark>
	}
	
	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0010 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureNW;</mark>
		<mark>FillABD(f);</mark>
		<mark>FillC(f);</mark>
	}
	
	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0100 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureSE;</mark>
		<mark>FillACD(f);</mark>
		<mark>FillB(f);</mark>
	}

	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0111 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureSW;</mark>
		<mark>FillA(f);</mark>
		<mark>FillBCD(f);</mark>
	}</pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/06-one-different.png" width="308" height="200">
						<figcaption>One corner per cell is different.</figcaption>
					</figure>
					
					<p>Partitioning cells in two different sections along the NS or EW lines is also simple.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0011 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureEW;</mark>
		<mark>FillAB(f);</mark>
		<mark>FillCD(f);</mark>
	}

	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0101 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureNS;</mark>
		<mark>FillAC(f);</mark>
		<mark>FillBD(f);</mark>
	}</pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/06-straight-split.png" width="190" height="240">
						<figcaption>Horizontal and vertical splits.</figcaption>
					</figure>
					
					<p>These were the easy cases, the remaining ones will require some more work.</p>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-06-triangulating-anew.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Working with more than Two States</h2>
					
					<p>Let's now consider the cases where two adjacent corners are the same, while the remaining two are different. This means that there are three different voxel states involved. This is still simple from the point of view of <code><b class="type">VoxelGrid</b></code>. Just ask the cell for the point where the three edges meet and fill the three parts.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0012 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureNEW;</mark>
		<mark>FillAB(f);</mark>
		<mark>FillC(f);</mark>
		<mark>FillD(f);</mark>
	}
	
	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0102 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureNSE;</mark>
		<mark>FillAC(f);</mark>
		<mark>FillB(f);</mark>
		<mark>FillD(f);</mark>
	}
	
	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0121 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureNSW;</mark>
		<mark>FillA(f);</mark>
		<mark>FillBD(f);</mark>
		<mark>FillC(f);</mark>
	}
	
	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0122 () {
		<mark><b class="type">FeaturePoint</b> f = cell.FeatureSEW;</mark>
		<mark>FillA(f);</mark>
		<mark>FillB(f);</mark>
		<mark>FillCD(f);</mark>
	}</pre>
					
					<p>Now it's up to <code><b class="type">VoxelCell</b></code> to figure out where these points are. This could get very involved, but let's be pragmatic and simply average the feature points when considering each involved edge pair. As there must be a feature point, if we can't find one, just average the edge crossing positions.</p>
					
					<aside>
						<h3>What about a least-squares approach?</h3>
						<div>
							<p>It makes sense to use a quadratic error formula to find a least-squares approximation of the best feature point. This is what is often used in advanced Marching Cubes implementations. The basic least-squares algorithm is not that complex, however it requires high precision to get usable results. You could use double-precision numbers to get around this limitation, but no one ends up doing this because of memory and performance constraints. You can formulate the problem such that you get around the precision limitations, but this involves complex matrix mathematics that would require a dedicated tutorial to explain properly. It's not cheap to compute either.
						</p></div>
					</aside>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/07-find-the-feature.png" width="150" height="150">
						<figcaption>Where lies the shared feature point?</figcaption>
					</figure>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureNEW {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="type">FeaturePoint</b> f = <b class="type">FeaturePoint</b>.Average(</mark>
				<mark>FeatureEW, FeatureNE, FeatureNW);</mark>
			<mark><b class="keyword">if</b> (!f.exists) {</mark>
				<mark>f.position = (a.YEdgePoint + b.YEdgePoint + c.XEdgePoint) / <span class="constant">3f</span>;</mark>
				<mark>f.exists = <b class="keyword">true</b>;</mark>
			<mark>}</mark>
			<mark><b class="keyword">return</b> f;</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureNSE {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="type">FeaturePoint</b> f = <b class="type">FeaturePoint</b>.Average(</mark>
				<mark>FeatureNS, FeatureSE, FeatureNE);</mark>
			<mark><b class="keyword">if</b> (!f.exists) {</mark>
				<mark>f.position = (a.XEdgePoint + b.YEdgePoint + c.XEdgePoint) / <span class="constant">3f</span>;</mark>
				<mark>f.exists = <b class="keyword">true</b>;</mark>
			<mark>}</mark>
			<mark><b class="keyword">return</b> f;</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureNSW {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="type">FeaturePoint</b> f = <b class="type">FeaturePoint</b>.Average(</mark>
				<mark>FeatureNS, FeatureNW, FeatureSW);</mark>
			<mark><b class="keyword">if</b> (!f.exists) {</mark>
				<mark>f.position = (a.XEdgePoint + a.YEdgePoint + c.XEdgePoint) / <span class="constant">3f</span>;</mark>
				<mark>f.exists = <b class="keyword">true</b>;</mark>
			<mark>}</mark>
			<mark><b class="keyword">return</b> f;</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureSEW {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="type">FeaturePoint</b> f = <b class="type">FeaturePoint</b>.Average(</mark>
				<mark>FeatureEW, FeatureSE, FeatureSW);</mark>
			<mark><b class="keyword">if</b> (!f.exists) {</mark>
				<mark>f.position = (a.XEdgePoint + a.YEdgePoint + b.YEdgePoint) / <span class="constant">3f</span>;</mark>
				<mark>f.exists = <b class="keyword">true</b>;</mark>
			<mark>}</mark>
			<mark><b class="keyword">return</b> f;</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>The <code><b class="type">FeaturePoint</b>.Average</code> method averages the features points, but only those that actually exist. And if none exists, then neither does the average.</p>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="keyword">static</b> <b class="type">FeaturePoint</b> Average (</mark>
		<mark><b class="type">FeaturePoint</b> a, <b class="type">FeaturePoint</b> b, <b class="type">FeaturePoint</b> c) {</mark>
		
		<mark><b class="type">FeaturePoint</b> average;</mark>
		<mark>average.position = <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>.zero;</mark>
		<mark><b class="type">float</b> features = <span class="constant">0f</span>;</mark>
		<mark><b class="keyword">if</b> (a.exists) {</mark>
			<mark>average.position += a.position;</mark>
			<mark>features += <span class="constant">1f</span>;</mark>
		<mark>}</mark>
		<mark><b class="keyword">if</b> (b.exists) {</mark>
			<mark>average.position += b.position;</mark>
			<mark>features += <span class="constant">1f</span>;</mark>
		<mark>}</mark>
		<mark><b class="keyword">if</b> (c.exists) {</mark>
			<mark>average.position += c.position;</mark>
			<mark>features += <span class="constant">1f</span>;</mark>
		<mark>}</mark>
		<mark><b class="keyword">if</b> (features &gt; <span class="constant">0f</span>) {</mark>
			<mark>average.position /= features;</mark>
			<mark>average.exists = <b class="keyword">true</b>;</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>average.exists = <b class="keyword">false</b>;</mark>
		<mark>}</mark>
		<mark><b class="keyword">return</b> average;</mark>
	<mark>}</mark></pre>
					
					<p>The result of all this is that a single sharp feature will be preserved, two or three sharp features will be averaged, and if we fail to find the right point we use the crossing's average position.</p>
					
					<p>However, there is something wrong with this approach. Our feature detection code expects both normals to have the same orientation. Either both point inward, or both point outward. But this will not always be the case if three different voxel states are involved.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/07-need-to-flip.png" width="150" height="150">
						<figcaption>Corner C is in trouble.</figcaption>
					</figure>
					
					<p>For each feature point we need to check whether the normals are consistent, and if not flip one of them to correct this. While we could do this every time we compute a feature point, it is only really needed for the more complex feature points. So let's duplicate the unchecked public properties and turn those into private checked ones for internal usage.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="type">FeaturePoint</b> <mark>CheckedFeatureSW</mark> {
		<b class="keyword">get</b> {
			<mark><a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2 = (a.state &lt; b.state) == (a.state &lt; c.state) ?</mark>
				<mark>a.yNormal : -a.yNormal;</mark>
			<b class="keyword">return</b> GetSharpFeature(a.XEdgePoint, a.xNormal, a.YEdgePoint, <mark>n2</mark>);
		}
	}
	
	<b class="keyword">private</b> <b class="type">FeaturePoint</b> <mark>CheckedFeatureSE</mark> {
		<b class="keyword">get</b> {
			<mark><a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2 = (b.state &lt; a.state) == (b.state &lt; c.state) ?</mark>
				<mark>b.yNormal : -b.yNormal;</mark>
			<b class="keyword">return</b> GetSharpFeature(a.XEdgePoint, a.xNormal, b.YEdgePoint, <mark>n2</mark>);
		}
	}
	
	<b class="keyword">private</b> <b class="type">FeaturePoint</b> <mark>CheckedFeatureNW</mark> {
		<b class="keyword">get</b> {
			<mark><a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2 = (c.state &lt; a.state) == (c.state &lt; d.state) ?</mark>
				<mark>c.xNormal : -c.xNormal;</mark>
			<b class="keyword">return</b> GetSharpFeature(a.YEdgePoint, a.yNormal, c.XEdgePoint, <mark>n2</mark>);
		}
	}
	
	<b class="keyword">private</b> <b class="type">FeaturePoint</b> <mark>CheckedFeatureNE</mark> {
		<b class="keyword">get</b> {
			<mark><a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2 = (d.state &lt; b.state) == (d.state &lt; c.state) ?</mark>
				<mark>b.yNormal : -b.yNormal;</mark>
			<b class="keyword">return</b> GetSharpFeature(c.XEdgePoint, c.xNormal, b.YEdgePoint, <mark>n2</mark>);
		}
	}
	
	<b class="keyword">private</b> <b class="type">FeaturePoint</b> <mark>CheckedFeatureNS</mark> {
		<b class="keyword">get</b> {
			<mark><a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2 = (a.state &lt; b.state) == (c.state &lt; d.state) ?</mark>
				<mark>c.xNormal : -c.xNormal;</mark>
			<b class="keyword">return</b> GetSharpFeature(a.XEdgePoint, a.xNormal, c.XEdgePoint, <mark>n2</mark>);
		}
	}</pre>
					
					<p>Now use these checked properties in the triple-edge feature properties. I only show the changes to <code>FeatureNEW</code>.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <b class="type">FeaturePoint</b> FeatureNEW {
		<b class="keyword">get</b> {
			<b class="type">FeaturePoint</b> f = <b class="type">FeaturePoint</b>.Average(
				<mark>CheckedFeatureEW</mark>, <mark>CheckedFeatureNE</mark>, <mark>CheckedFeatureNW</mark>);
			<b class="keyword">if</b> (!f.exists) {
				f.position = (a.YEdgePoint + b.YEdgePoint + c.XEdgePoint) / <span class="constant">3f</span>;
				f.exists = <b class="keyword">true</b>;
			}
			<b class="keyword">return</b> f;
		}
	}</pre>
					
					<figure>
						<img alt="correct" src="./Marching Squares 5, a Unity C# Tutorial_files/07-feature-correct.png" width="110" height="110">
						<img alt="incorrect" src="./Marching Squares 5, a Unity C# Tutorial_files/07-feature-incorrect.png" width="110" height="110">
						<figcaption>Correct vs. incorrect feature placement.</figcaption>
					</figure>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-07-working-with-more-than-two-states.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Revisiting the Ambiguous Cases</h2>
					
					<p><code><b class="type">VoxelGrid</b>.Triangulate0110</code> covers the diagonal cell configuration when there are exactly two different voxel states involved. Let's first only consider the AD connection. Start by requesting all feature points, then determine if there is a diagonal connection, and if so only include features that don't cross the diagonal.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0110 () {
		<mark><b class="type">FeaturePoint</b></mark>
			<mark>fA = cell.FeatureSW, fB = cell.FeatureSE,</mark>
			<mark>fC = cell.FeatureNW, fD = cell.FeatureNE;</mark>
		
		<mark><b class="keyword">if</b> (cell.HasConnectionAD(fA, fD)) {</mark>
			<mark>fB.exists &amp;= cell.IsInsideABD(fB.position);</mark>
			<mark>fC.exists &amp;= cell.IsInsideACD(fC.position);</mark>
			<mark>FillADToB(fB);</mark>
			<mark>FillADToC(fC);</mark>
			<mark>FillB(fB);</mark>
			<mark>FillC(fC);</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<p>The logic of the new methods for <code><b class="type">VoxelCell</b></code> come from the old grid, updated to take advantage of the new feature points.</p>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <b class="type">bool</b> HasConnectionAD (<b class="type">FeaturePoint</b> fA, <b class="type">FeaturePoint</b> fD) {</mark>
		<mark><b class="keyword">if</b> (fA.exists) {</mark>
			<mark><b class="keyword">if</b> (fD.exists) {</mark>
				<mark><b class="keyword">if</b> (IsBelowLine(fA.position, b.YEdgePoint, fD.position)) {</mark>
					<mark><b class="keyword">if</b> (IsBelowLine(fA.position, fD.position, c.XEdgePoint) ||</mark>
					    <mark>IsBelowLine(fD.position, fA.position, a.XEdgePoint)) {</mark>
						<mark><b class="keyword">return</b> <b class="keyword">true</b>;</mark>
					<mark>}</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> <b class="keyword">if</b> (IsBelowLine(fA.position, fD.position, c.XEdgePoint) &amp;&amp;</mark>
				         <mark>IsBelowLine(fD.position, a.YEdgePoint, fA.position)) {</mark>
					<mark><b class="keyword">return</b> <b class="keyword">true</b>;</mark>
				<mark>}</mark>
				<mark><b class="keyword">return</b> <b class="keyword">false</b>;</mark>
			<mark>}</mark>
			<mark><b class="keyword">return</b> IsBelowLine(fA.position, b.YEdgePoint, c.XEdgePoint);</mark>
		<mark>}</mark>
		<mark><b class="keyword">return</b> fD.exists &amp;&amp;</mark>
			<mark>IsBelowLine(fD.position, a.YEdgePoint, a.XEdgePoint);</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">bool</b> IsInsideABD (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> point) {</mark>
		<mark><b class="keyword">return</b> IsBelowLine(point, a.position, d.position);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="type">bool</b> IsInsideACD (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> point) {</mark>
		<mark><b class="keyword">return</b> IsBelowLine(point, d.position, a.position);</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">private</b> <b class="keyword">static</b> <b class="type">bool</b> IsBelowLine (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> p, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> start, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> end) {</mark>
		<mark><b class="type">float</b> determinant =</mark>
			<mark>(end.x - start.x) * (p.y - start.y) -</mark>
				<mark>(end.y - start.y) * (p.x - start.x);</mark>
		<mark><b class="keyword">return</b> determinant &lt; <span class="constant">0f</span>;</mark>
	<mark>}</mark></pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/08-ad.png" width="150" height="130">
						<figcaption>Diagonal connection along AD.</figcaption>
					</figure>
					
					<p>Now to support the other diagonal as well. Adding it to <code><b class="type">VoxelGrid</b>.Triangulate0110</code> is simple.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0110 () {
		<b class="type">FeaturePoint</b>
			fA = cell.FeatureSW, fB = cell.FeatureSE,
			fC = cell.FeatureNW, fD = cell.FeatureNE;
		
		<b class="keyword">if</b> (cell.HasConnectionAD(fA, fD)) {
			…
		}
		<mark><b class="keyword">else</b> <b class="keyword">if</b> (cell.HasConnectionBC(fB, fC)) {</mark>
			<mark>fA.exists &amp;= cell.IsInsideABC(fA.position);</mark>
			<mark>fD.exists &amp;= cell.IsInsideBCD(fD.position);</mark>
			<mark>FillA(fA);</mark>
			<mark>FillD(fD);</mark>
			<mark>FillBCToA(fA);</mark>
			<mark>FillBCToD(fD);</mark>
		<mark>}</mark>
	}</pre>
					
					<p><code><b class="type">VoxelCell</b></code> has to do all the hard work.</p>
					
					<pre translate="no"><mark><b class="keyword">public</b> <b class="type">bool</b> HasConnectionBC (<b class="type">FeaturePoint</b> fB, <b class="type">FeaturePoint</b> fC) {</mark>
		<mark><b class="keyword">if</b> (fB.exists) {</mark>
			<mark><b class="keyword">if</b> (fC.exists) {</mark>
				<mark><b class="keyword">if</b> (IsBelowLine(fC.position, a.XEdgePoint, fB.position)) {</mark>
					<mark><b class="keyword">if</b> (IsBelowLine(fC.position, fB.position, b.YEdgePoint) ||</mark>
					    <mark>IsBelowLine(fB.position, fC.position, a.YEdgePoint)) {</mark>
						<mark><b class="keyword">return</b> <b class="keyword">true</b>;</mark>
					<mark>}</mark>
				<mark>}</mark>
				<mark><b class="keyword">else</b> <b class="keyword">if</b> (IsBelowLine(fC.position, fB.position, b.YEdgePoint) &amp;&amp;</mark>
				         <mark>IsBelowLine(fB.position, c.XEdgePoint, fC.position)) {</mark>
					<mark><b class="keyword">return</b> <b class="keyword">true</b>;</mark>
				<mark>}</mark>
				<mark><b class="keyword">return</b> <b class="keyword">false</b>;</mark>
			<mark>}</mark>
			<mark><b class="keyword">return</b> IsBelowLine(fB.position, c.XEdgePoint, a.YEdgePoint);</mark>
		<mark>}</mark>
		<mark><b class="keyword">return</b> fC.exists &amp;&amp;</mark>
			<mark>IsBelowLine(fC.position, a.XEdgePoint, b.YEdgePoint);</mark>
	<mark>}</mark>
	
	<mark><b class="keyword">public</b> <b class="type">bool</b> IsInsideABC (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> point) {</mark>
		<mark><b class="keyword">return</b> IsBelowLine(point, c.position, b.position);</mark>
	<mark>}</mark>

	<mark><b class="keyword">public</b> <b class="type">bool</b> IsInsideBCD (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> point) {</mark>
		<mark><b class="keyword">return</b> IsBelowLine(point, b.position, c.position);</mark>
	<mark>}</mark></pre>
					
					<p>What we do when we find no diagonal connection depends on whether one of the voxel states is the empty one. If all voxels are filled, then they have to share a central feature point. If one of the voxel pairs is empty, then the other two can exist independent of each other, forming an opening.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0110 () {
		<b class="type">FeaturePoint</b>
			fA = cell.FeatureSW, fB = cell.FeatureSE,
			fC = cell.FeatureNW, fD = cell.FeatureNE;
		
		<b class="keyword">if</b> (cell.HasConnectionAD(fA, fD)) {
			…
		}
		<b class="keyword">else</b> <b class="keyword">if</b> (cell.HasConnectionBC(fB, fC)) {
			…
		}
		<mark><b class="keyword">else</b> <b class="keyword">if</b> (cell.a.Filled &amp;&amp; cell.b.Filled) {</mark>
			<mark>FillJoinedCorners(fA, fB, fC, fD);</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>FillA(fA);</mark>
			<mark>FillB(fB);</mark>
			<mark>FillC(fC);</mark>
			<mark>FillD(fD);</mark>
		<mark>}</mark>
	}</pre>
					
					<p>Filling the joined corners requires averaging all four feature points. And if none exist, we have to settle for the average of the four edge crossing positions of the cell.</p>
					
					<pre translate="no">	<mark><b class="keyword">private</b> <b class="keyword">void</b> FillJoinedCorners (</mark>
		<mark><b class="type">FeaturePoint</b> fA, <b class="type">FeaturePoint</b> fB, <b class="type">FeaturePoint</b> fC, <b class="type">FeaturePoint</b> fD) {</mark>
		
		<mark><b class="type">FeaturePoint</b> point = <b class="type">FeaturePoint</b>.Average(fA, fB, fC, fD);</mark>
		<mark><b class="keyword">if</b> (!point.exists) {</mark>
			<mark>point.position = cell.AverageNESW;</mark>
			<mark>point.exists = <b class="keyword">true</b>;</mark>
		<mark>}</mark>
		<mark>FillA(point);</mark>
		<mark>FillB(point);</mark>
		<mark>FillC(point);</mark>
		<mark>FillD(point);</mark>
	<mark>}</mark></pre>
					
					<p>This requires an additional <code><b class="type">FeaturePoint</b>.Average</code> method which works with four feature points instead of three. As this is a very simple change I leave it up to you to add it.</p>
					
					<p>We also need a new property for <code><b class="type">VoxelCell</b></code> which simply averages the four edge positions.</p>
					
					<pre translate="no">	<mark><b class="keyword">public</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> AverageNESW {</mark>
		<mark><b class="keyword">get</b> {</mark>
			<mark><b class="keyword">return</b> (a.XEdgePoint + a.YEdgePoint +</mark>
			        <mark>b.YEdgePoint + c.XEdgePoint) * <span class="constant">0.25f</span>;</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/08-diagonals.png" width="420" height="234">
						<figcaption>Diagonal connections and passages.</figcaption>
					</figure>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-08-revisiting-the-ambiguous-cases.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Drawing better Circles</h2>
					
					<p>While we're working on diagonals, let's improve circles. The detection of connections formed by narrow circles fails because the edges are nearly parallel and feature points end up racing to infinity in either positive or negative direction. This wasn't so bad when we still clamped feature points, but without this trick they always fall apart.</p>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/09-bad-circles.png" width="310" height="250">
						<figcaption>Bad circles.</figcaption>
					</figure>
					
					<p>A possible solution is to add a threshold to decide whether lines are parallel. Of course we make this configurable. First add maximum angle setting to <code><b class="type">VoxelMap</b></code>, with a default of five degrees.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <b class="type">float</b> maxFeatureAngle = <span class="constant">135f</span><mark>, maxParallelAngle = <span class="constant">5f</span></mark>;</pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/09-max-parallel-angle.png" width="320" height="180">
						<figcaption>Setting a maximum parallel angle.</figcaption>
					</figure>
					
					<p>Just like the maximum feature angle, we pass it to the grids when we initialize them.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> CreateChunk (<b class="type">int</b> i, <b class="type">int</b> x, <b class="type">int</b> y) {
		<b class="type">VoxelGrid</b> chunk = <a class="unity-method" href="http://docs.unity3d.com/Documentation/ScriptReference/Object.Instantiate.html">Instantiate</a>(voxelGridPrefab) <b class="keyword">as</b> <b class="type">VoxelGrid</b>;
		chunk.Initialize(
			voxelResolution, chunkSize, maxFeatureAngle<mark>, maxParallelAngle</mark>);
		…
	}</pre>
					
					<p>Then <code><b class="type">VoxelGrid</b></code> computes the cosine and stores it in its <code><b class="type">VoxelCell</b></code> as the parallel limit.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <b class="keyword">void</b> Initialize (
		<b class="type">int</b> resolution, <b class="type">float</b> size,
		<b class="type">float</b> maxFeatureAngle<mark>, <b class="type">float</b> maxParallelAngle</mark>) {

		cell.sharpFeatureLimit = <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Cos(maxFeatureAngle * <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Deg2Rad);
		<mark>cell.parallelLimit = <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Cos(maxParallelAngle * <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.html">Mathf</a>.Deg2Rad);</mark>
		…
	}</pre>
					
					<p><code><b class="type">VoxelCell</b></code> can them figure out if two normals belong to parallel lines. As we perform this test for diagonal connections and those can end up with inconsistent normals, let's tell the method whether a normal should be flipped or not.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <b class="type">float</b> sharpFeatureLimit<mark>, parallelLimit</mark>;
					
	<mark><b class="keyword">private</b> <b class="type">bool</b> IsParallel (<a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n1, <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a> n2, <b class="type">bool</b> flip) {</mark>
		<mark><b class="keyword">return</b> <a class="unity-type" href="http://docs.unity3d.com/Documentation/ScriptReference/Vector2.html">Vector2</a>.Dot(n1, flip ? -n2 : n2) &gt; parallelLimit;</mark>
	<mark>}</mark></pre>
					
					<p>Now we can check for a parallel connection first whenever we're asked to look for a diagonal connection.</p>
					
					<pre translate="no">	<b class="keyword">public</b> <b class="type">bool</b> HasConnectionAD (<b class="type">FeaturePoint</b> fA, <b class="type">FeaturePoint</b> fD) {
		<mark><b class="type">bool</b> flip = (a.state &lt; b.state) == (a.state &lt; c.state);</mark>
		<mark><b class="keyword">if</b> (</mark>
			<mark>IsParallel(a.xNormal, a.yNormal, flip) ||</mark>
			<mark>IsParallel(c.xNormal, b.yNormal, flip)) {</mark>
			<mark><b class="keyword">return</b> <b class="keyword">true</b>;</mark>
		<mark>}</mark>
		…
	}
	
	<b class="keyword">public</b> <b class="type">bool</b> HasConnectionBC (<b class="type">FeaturePoint</b> fB, <b class="type">FeaturePoint</b> fC) {
		<mark><b class="type">bool</b> flip = (b.state &lt; a.state) == (b.state &lt; d.state);</mark>
		<mark><b class="keyword">if</b> (</mark>
			<mark>IsParallel(a.xNormal, b.yNormal, flip) ||</mark>
			<mark>IsParallel(c.xNormal, a.yNormal, flip)) {</mark>
			<mark><b class="keyword">return</b> <b class="keyword">true</b>;</mark>
		<mark>}</mark>
		…
	}</pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/09-good-circles.png" width="310" height="250">
						<figcaption>Good circles.</figcaption>
					</figure>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-09-drawing-better-circles.unitypackage" download="" rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Covering the Last Cases</h2>
					
					<p>Back to <code><b class="type">VoxelGrid</b></code>, cases 0112 and 0120 cover diagonals with two different voxel states on either side. Because diagonally connecting two voxels with different states doesn't really work, these methods are actually about half as complex as when only two different voxel states are involved.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0112 () {
		<mark><b class="type">FeaturePoint</b></mark>
			<mark>fA = cell.FeatureSW, fB = cell.FeatureSE,</mark>
			<mark>fC = cell.FeatureNW, fD = cell.FeatureNE;</mark>
		
		<mark><b class="keyword">if</b> (cell.HasConnectionBC(fB, fC)) {</mark>
			<mark>fA.exists &amp;= cell.IsInsideABC(fA.position);</mark>
			<mark>fD.exists &amp;= cell.IsInsideBCD(fD.position);</mark>
			<mark>FillA(fA);</mark>
			<mark>FillD(fD);</mark>
			<mark>FillBCToA(fA);</mark>
			<mark>FillBCToD(fD);</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> <b class="keyword">if</b> (cell.b.Filled || cell.HasConnectionAD(fA, fD)) {</mark>
			<mark>FillJoinedCorners(fA, fB, fC, fD);</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>FillA(fA);</mark>
			<mark>FillD(fD);</mark>
		<mark>}</mark>
	}
	
	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0120 () {
		<mark><b class="type">FeaturePoint</b></mark>
			<mark>fA = cell.FeatureSW, fB = cell.FeatureSE,</mark>
			<mark>fC = cell.FeatureNW, fD = cell.FeatureNE;</mark>
		
		<mark><b class="keyword">if</b> (cell.HasConnectionAD(fA, fD)) {</mark>
			<mark>fB.exists &amp;= cell.IsInsideABD(fB.position);</mark>
			<mark>fC.exists &amp;= cell.IsInsideACD(fC.position);</mark>
			<mark>FillADToB(fB);</mark>
			<mark>FillADToC(fC);</mark>
			<mark>FillB(fB);</mark>
			<mark>FillC(fC);</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> <b class="keyword">if</b> (cell.a.Filled || cell.HasConnectionBC(fB, fC)) {</mark>
			<mark>FillJoinedCorners(fA, fB, fC, fD);</mark>
		<mark>}</mark>
		<mark><b class="keyword">else</b> {</mark>
			<mark>FillB(fB);</mark>
			<mark>FillC(fC);</mark>
		<mark>}</mark>
	}</pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/10-mixed-diagonals.png" width="160" height="160">
						<figcaption>Different states along diagonals.</figcaption>
					</figure>
					
					<p>The last case is 0123, the only one that has four different voxel states in it. Fortunately this is simply another job for <code>FillJoinedCorners</code>.</p>
					
					<pre translate="no">	<b class="keyword">private</b> <b class="keyword">void</b> Triangulate0123 () {
		<mark>FillJoinedCorners(</mark>
			<mark>cell.FeatureSW, cell.FeatureSE,</mark>
			<mark>cell.FeatureNW, cell.FeatureNE);</mark>
	}</pre>
					
					<figure>
						<img src="./Marching Squares 5, a Unity C# Tutorial_files/10-fully-multicolored.png" width="370" height="330">
						<figcaption>Full support for multiple colors.</figcaption>
					</figure>
					
					<p>I hope you enjoyed this tutorial series about Marching Squares. There is still much more that could be covered about this subject, but a reasonable foundation has been laid. What you do with it is up to you!</p>
					
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/ms5-10-covering-the-last-cases.unitypackage" download="" rel="nofollow">unitypackage</a>
					<a href="https://catlikecoding.com/unity/tutorials/marching-squares-5/Marching-Squares-5.pdf" download="" rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="https://catlikecoding.com/unity/tutorials/">tutorials</a>? Are they useful?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="./Marching Squares 5, a Unity C# Tutorial_files/become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="https://catlikecoding.com/unity/tutorials/donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="https://catlikecoding.com/jasper-flick/" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="./Marching Squares 5, a Unity C# Tutorial_files/tutorials.js.下载"></script><div id="theme-switcher">switch theme</div>
	
</body></html>